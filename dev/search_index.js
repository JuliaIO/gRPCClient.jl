var documenterSearchIndex = {"docs":
[{"location":"#gRPCClient.jl","page":"gRPCClient.jl","title":"gRPCClient.jl","text":"gRPCClient.jl aims to be a production grade gRPC client emphasizing performance and reliability.","category":"section"},{"location":"#Features","page":"gRPCClient.jl","title":"Features","text":"Unary+Streaming RPC\nHTTP/2 connection multiplexing\nSynchronous and asynchronous interfaces\nThread safe\nSSL/TLS\n\nThe client is missing a few features which will be added over time if there is sufficient interest:\n\nOAuth2\nCompression","category":"section"},{"location":"#Getting-Started","page":"gRPCClient.jl","title":"Getting Started","text":"","category":"section"},{"location":"#Test-gRPC-Server","page":"gRPCClient.jl","title":"Test gRPC Server","text":"All examples in the documentation are run against a test server written in Go. You can run it by doing the following:\n\ncd test/go\n\n# Build\ngo build -o grpc_test_server\n\n# Run\n./grpc_test_server","category":"section"},{"location":"#Code-Generation","page":"gRPCClient.jl","title":"Code Generation","text":"Note: support for this is currently being upstreamed into ProtoBuf.jl. Until then, make sure you add the feature branch with gRPC code generation support:\n\npkg> add https://github.com/csvance/ProtoBuf.jl#external-service-support\n\ngRPCClient.jl integrates with ProtoBuf.jl to automatically generate Julia client stubs for calling gRPC. \n\nusing ProtoBuf\nusing gRPCClient\n\n# Register our service codegen with ProtoBuf.jl\ngrpc_register_service_codegen()\n\n# Creates Julia bindings for the messages and RPC defined in test.proto\nprotojl(\"test/proto/test.proto\", \".\", \"test/gen\")","category":"section"},{"location":"#Example-Usage","page":"gRPCClient.jl","title":"Example Usage","text":"See here for examples covering all provided interfaces for both unary and streaming gRPC calls. ","category":"section"},{"location":"#API","page":"gRPCClient.jl","title":"API","text":"","category":"section"},{"location":"#Package-Initialization-/-Shutdown","page":"gRPCClient.jl","title":"Package Initialization / Shutdown","text":"","category":"section"},{"location":"#RPC","page":"gRPCClient.jl","title":"RPC","text":"","category":"section"},{"location":"#Unary","page":"gRPCClient.jl","title":"Unary","text":"","category":"section"},{"location":"#Streaming","page":"gRPCClient.jl","title":"Streaming","text":"","category":"section"},{"location":"#Exceptions","page":"gRPCClient.jl","title":"Exceptions","text":"","category":"section"},{"location":"#gRPCClientUtils.jl","page":"gRPCClient.jl","title":"gRPCClientUtils.jl","text":"A module for benchmarking and stress testing has been included in utils/gRPCClientUtils.jl. In order to add it to your test environment:\n\nusing Pkg\nPkg.add(path=\"utils/gRPCClientUtils.jl\")","category":"section"},{"location":"#Benchmarks","page":"gRPCClient.jl","title":"Benchmarks","text":"All benchmarks run against the Test gRPC Server in test/go. See the relevant documentation for information on how to run this.","category":"section"},{"location":"#All-Benchmarks-w/-PrettyTables.jl","page":"gRPCClient.jl","title":"All Benchmarks w/ PrettyTables.jl","text":"using gRPCClientUtils\n\nbenchmark_table()\n\n╭──────────────────────────────────┬─────────┬────────┬─────────────┬──────────┬────────────┬──────────────┬─────────┬──────┬──────╮\n│                        Benchmark │       N │ Memory │ Allocations │ Duration │ Throughput │ Avg duration │ Std-dev │  Min │  Max │\n│                                  │   calls │    MiB │             │        s │    calls/s │           μs │      μs │   μs │   μs │\n├──────────────────────────────────┼─────────┼────────┼─────────────┼──────────┼────────────┼──────────────┼─────────┼──────┼──────┤\n│                    workload_smol │   94000 │   3.74 │       85110 │     5.01 │      18756 │           53 │     4.2 │   47 │   71 │\n│        workload_32_224_224_uint8 │    2800 │  63.78 │        9230 │     5.11 │        548 │         1826 │   378.6 │ 1598 │ 2657 │\n│       workload_streaming_request │ 2566000 │   0.61 │        6615 │     4.99 │     514001 │            2 │    0.61 │    1 │   16 │\n│      workload_streaming_response │  985000 │   13.0 │       27721 │      5.0 │     197101 │            5 │    0.48 │    4 │    7 │\n│ workload_streaming_bidirectional │ 2568000 │   1.98 │       25503 │     4.99 │     514539 │            2 │     0.5 │    1 │   12 │\n╰──────────────────────────────────┴─────────┴────────┴─────────────┴──────────┴────────────┴──────────────┴─────────┴──────┴──────╯","category":"section"},{"location":"#Stress-Workloads","page":"gRPCClient.jl","title":"Stress Workloads","text":"In addition to benchmarks, a number of workloads based on these are available:\n\nstress_workload_smol()\nstress_workload_32_224_224_uint8()\nstress_workload_streaming_request()\nstress_workload_streaming_response()\nstress_workload_streaming_bidirectional()\n\nThese run forever, and are useful to help identify any stability issues or resource leaks.","category":"section"},{"location":"#gRPCClient.grpc_init-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_init","text":"grpc_init([grpc_curl::gRPCCURL])\n\nInitializes the gRPCCURL object. This should be called once before making gRPC calls. There is no harm in calling this more than once (ie by different packages/dependencies). Typical usage looks like this:\n\ngrpc_init()\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001)\n\n# Make some gRPC calls \n\n# Shut down the global gRPC handle\ngrpc_shutdown()\n\nUnless specifying a gRPCCURL the global one provided by grpc_global_handle() is used. Each gRPCCURL state has its own connection pool and request semaphore, so sometimes you may want to manage your own like shown below:\n\ngrpc_myapp = gRPCCURL()\ngrpc_init(grpc_myapp)\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001; grpc=grpc_myapp)\n\n# Make some gRPC calls \n\n# Only shuts down your gRPC handle\ngrpc_shutdown(grpc_myapp)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_shutdown-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_shutdown","text":"grpc_shutdown([grpc_curl::gRPCCURL])\n\nShuts down the gRPCCURL. This neatly cleans up all active connections and requests. Useful for calling during development with Revise. Unless specifying the gRPCCURL, the global one provided by grpc_global_handle() is shutdown.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_global_handle-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_global_handle","text":"grpc_global_handle()\n\nReturns the global gRPCCURL state which contains a libCURL multi handle. By default all gRPC clients use this multi in order to ensure that HTTP/2 multiplexing happens where possible.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return a gRPCRequest object without waiting for the response.  In order to wait on / retrieve the result once its ready, call grpc_async_await. This is ideal when you need to send many requests in parallel and waiting on each response before sending the next request would things down.\n\nusing gRPCClient\n\ngrpc_init()\n\n# Include the generated bindings\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Create a client bound to a specific RPC\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# Make a syncronous request and get back a TestResponse\nresponse = grpc_sync_request(client, TestRequest(1, zeros(UInt64, 1)))\n@info response\n\n# Make some async requests and await their TestResponse\nrequests = Vector{gRPCRequest}()\nfor i in 1:10\n    push!(\n        requests, \n        grpc_async_request(client, TestRequest(1, zeros(UInt64, 1)))\n    )\nend\n\nfor request in requests\n    response = grpc_async_await(client, request)\n    @info response\nend\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest, Channel{gRPCAsyncChannelResponse{TResponse}}, Int64}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest, channel::Channel{gRPCAsyncChannelResponse{TResponse}}, index::Int64) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return. When the request is complete a background task will put the response in the provided channel. This has the advantage over the request / await patern in that you can handle responses immediately after they are recieved in any order.\n\nusing gRPCClient\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Connect to the test server\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\nN = 10\n\nchannel = Channel{gRPCAsyncChannelResponse{TestResponse}}(N)\n\nfor (index, request) in enumerate([TestRequest(i, zeros(UInt64, i)) for i in 1:N])\n     grpc_async_request(client, request, channel, index)\nend\n\nfor i in 1:N\n    cr = take!(channel)\n    # Check if an exception was thrown, if so throw it here\n    !isnothing(cr.ex) && throw(cr.ex)\n\n    # If this does not hold true, then the requests and responses have gotten mixed up.\n    @assert length(cr.response.data) == cr.index\nend\n\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_await","text":"grpc_async_await(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nWait for the request to complete and return the response when it is ready. Throws any exceptions that were encountered during handling of the request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_sync_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_sync_request","text":"grpc_sync_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nDo a synchronous gRPC request: send the request and wait for the response before returning it.  Under the hood this just calls grpc_async_request and grpc_async_await\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, false}, Channel{TRequest}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,true,TResponse,false}, request::Channel{TRequest}) where {TRequest<:Any,TResponse<:Any}\n\nStart a requesting streaming gRPC request.\n\nusing gRPCClient\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestClientStreamRPC_Client(\"localhost\", 8001)\nrequest_c = Channel{TestRequest}(16)\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\n\nreq = grpc_async_request(client, request_c)\n\n# Must close the request channel when done sending requests\nclose(request_c)\n\n# Get the response\ntest_response = grpc_async_await(client, req)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, true}, TRequest, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,true},request::TRequest,response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a response streaming gRPC request.\n\nusing gRPCClient\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestServerStreamRPC_Client(\"localhost\", 8001)\n\nresponse_c = Channel{TestResponse}(16)\n\nreq = grpc_async_request(\n    client,\n    TestRequest(1, zeros(UInt64, 1)),\n    response_c,\n)\ntest_response = take!(response_c)\n\n# Raise any exceptions encountered during the request\ngrpc_async_await(req) \n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, true}, Channel{TRequest}, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,true,TResponse,true},request::Channel{TRequest},response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a bidirectional gRPC request.\n\nusing gRPCClient\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestBidirectionalStreamRPC_Client(\"localhost\", 8001)\n\nrequest_c = Channel{TestRequest}(16)\nresponse_c = Channel{TestResponse}(16)\n\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\nreq = grpc_async_request(client, request_c, response_c)\ntest_response = take!(response_c)\n\n# Must close the request channel when done sending requests\nclose(request_c)\n# Raise any exceptions encountered during the request\ngrpc_async_await(req) \n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_await","text":"grpc_async_await(client::gRPCServiceClient{TRequest,true,TResponse,false},request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nRaise any exceptions encountered during the streaming request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.gRPCServiceCallException","page":"gRPCClient.jl","title":"gRPCClient.gRPCServiceCallException","text":"Exception type that is thrown when something goes wrong while calling an RPC. This can either be triggered by the servers response code or by the client when something fails.\n\nThis exception type has two fields:\n\ngrpc_status::Int - See here for an indepth explanation of each status.\nmessage::String\n\n\n\n\n\n","category":"type"}]
}
