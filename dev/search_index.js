var documenterSearchIndex = {"docs":
[{"location":"#gRPCClient.jl","page":"gRPCClient.jl","title":"gRPCClient.jl","text":"gRPCClient.jl aims to be a production grade gRPC client emphasizing performance and reliability.","category":"section"},{"location":"#Features","page":"gRPCClient.jl","title":"Features","text":"Unary+Streaming RPC\nHTTP/2 connection multiplexing\nSynchronous and asynchronous interfaces\nThread safe\nSSL/TLS\n\nThe client is missing a few features which will be added over time if there is sufficient interest:\n\nOAuth2\nCompression","category":"section"},{"location":"#Getting-Started","page":"gRPCClient.jl","title":"Getting Started","text":"","category":"section"},{"location":"#Test-gRPC-Server","page":"gRPCClient.jl","title":"Test gRPC Server","text":"All examples in the documentation are run against a test server written in Go. You can run it by doing the following:\n\ncd test/go\n\n# Build\ngo build -o grpc_test_server\n\n# Run\n./grpc_test_server","category":"section"},{"location":"#Code-Generation","page":"gRPCClient.jl","title":"Code Generation","text":"Note: support for this is currently being upstreamed into ProtoBuf.jl. Until then, make sure you add the feature branch with gRPC code generation support:\n\npkg> add https://github.com/csvance/ProtoBuf.jl#external-service-support\n\ngRPCClient.jl integrates with ProtoBuf.jl to automatically generate Julia client stubs for calling gRPC. \n\nusing ProtoBuf\nusing gRPCClient\n\n# Register our service codegen with ProtoBuf.jl\ngrpc_register_service_codegen()\n\n# Creates Julia bindings for the messages and RPC defined in test.proto\nprotojl(\"test/proto/test.proto\", \".\", \"test/gen\")","category":"section"},{"location":"#Example-Usage","page":"gRPCClient.jl","title":"Example Usage","text":"See here for examples covering all provided interfaces for both unary and streaming gRPC calls. ","category":"section"},{"location":"#API","page":"gRPCClient.jl","title":"API","text":"","category":"section"},{"location":"#Package-Initialization-/-Shutdown","page":"gRPCClient.jl","title":"Package Initialization / Shutdown","text":"","category":"section"},{"location":"#Generated-ServiceClient-Constructors","page":"gRPCClient.jl","title":"Generated ServiceClient Constructors","text":"When you generate service stubs using ProtoBuf.jl, a constructor method is automatically created for each RPC endpoint. These constructors create gRPCServiceClient instances that are used to make RPC calls.","category":"section"},{"location":"#Constructor-Signature","page":"gRPCClient.jl","title":"Constructor Signature","text":"For a service method named TestRPC in service TestService, the generated constructor will have the form:\n\nTestService_TestRPC_Client(\n    host, port;\n    secure=false,\n    grpc=grpc_global_handle(),\n    deadline=10,\n    keepalive=60,\n    max_send_message_length = 4*1024*1024,\n    max_recieve_message_length = 4*1024*1024,\n)","category":"section"},{"location":"#Parameters","page":"gRPCClient.jl","title":"Parameters","text":"host: The hostname or IP address of the gRPC server (e.g., \"localhost\", \"api.example.com\")\nport: The port number the gRPC server is listening on (e.g., 50051)\nsecure: A Bool that controls whether HTTPS/gRPCS (when true) or HTTP/gRPC (when false) is used for the connection. Default: false\ngrpc: The global gRPC handle obtained from grpc_global_handle(). This manages the underlying libcurl multi-handle for HTTP/2 multiplexing. Default: grpc_global_handle()\ndeadline: The gRPC deadline in seconds. If a request takes longer than this time limit, it will be cancelled and raise an exception. Default: 10\nkeepalive: The TCP keepalive interval in seconds. This sets both CURLOPT_TCP_KEEPINTVL (interval between keepalive probes) and CURLOPT_TCP_KEEPIDLE (time before first keepalive probe) to help detect broken connections. Default: 60\nmax_send_message_length: The maximum size in bytes for messages sent to the server. Attempting to send messages larger than this will raise an exception. Default: 4*1024*1024 (4 MiB)\nmax_recieve_message_length: The maximum size in bytes for messages received from the server. Receiving messages larger than this will raise an exception. Default: 4*1024*1024 (4 MiB)","category":"section"},{"location":"#Example","page":"gRPCClient.jl","title":"Example","text":"# Create a client for the TestRPC endpoint\nclient = TestService_TestRPC_Client(\n    \"localhost\", 50051;\n    secure=true,  # Use HTTPS/gRPCS\n    deadline=30,  # 30 second timeout\n    max_send_message_length=10*1024*1024,  # 10 MiB max send\n    max_recieve_message_length=10*1024*1024  # 10 MiB max receive\n)","category":"section"},{"location":"#RPC","page":"gRPCClient.jl","title":"RPC","text":"","category":"section"},{"location":"#Unary","page":"gRPCClient.jl","title":"Unary","text":"","category":"section"},{"location":"#Streaming","page":"gRPCClient.jl","title":"Streaming","text":"","category":"section"},{"location":"#Exceptions","page":"gRPCClient.jl","title":"Exceptions","text":"","category":"section"},{"location":"#gRPCClientUtils.jl","page":"gRPCClient.jl","title":"gRPCClientUtils.jl","text":"A module for benchmarking and stress testing has been included in utils/gRPCClientUtils.jl. In order to add it to your test environment:\n\nusing Pkg\nPkg.add(path=\"utils/gRPCClientUtils.jl\")","category":"section"},{"location":"#Benchmarks","page":"gRPCClient.jl","title":"Benchmarks","text":"All benchmarks run against the Test gRPC Server in test/go. See the relevant documentation for information on how to run this.","category":"section"},{"location":"#All-Benchmarks-w/-PrettyTables.jl","page":"gRPCClient.jl","title":"All Benchmarks w/ PrettyTables.jl","text":"using gRPCClientUtils\n\nbenchmark_table()\n\n╭──────────────────────────────────┬─────────────┬────────────────┬────────────┬──────────────┬─────────┬──────┬──────╮\n│                        Benchmark │  Avg Memory │     Avg Allocs │ Throughput │ Avg duration │ Std-dev │  Min │  Max │\n│                                  │ KiB/message │ allocs/message │    calls/s │           μs │      μs │   μs │   μs │\n├──────────────────────────────────┼─────────────┼────────────────┼────────────┼──────────────┼─────────┼──────┼──────┤\n│                    workload_smol │        2.95 │           72.5 │      18014 │           56 │    3.08 │   50 │   64 │\n│        workload_32_224_224_uint8 │       637.0 │           79.7 │        567 │         1762 │   99.07 │ 1628 │ 1911 │\n│       workload_streaming_request │        0.86 │            6.5 │     341851 │            3 │    1.68 │    2 │   30 │\n│      workload_streaming_response │        13.0 │           27.7 │      64515 │           16 │    5.12 │    6 │   33 │\n│ workload_streaming_bidirectional │        1.41 │           25.6 │     102072 │           10 │    6.23 │    4 │   52 │\n╰──────────────────────────────────┴─────────────┴────────────────┴────────────┴──────────────┴─────────┴──────┴──────╯","category":"section"},{"location":"#Stress-Workloads","page":"gRPCClient.jl","title":"Stress Workloads","text":"In addition to benchmarks, a number of workloads based on these are available:\n\nstress_workload_smol()\nstress_workload_32_224_224_uint8()\nstress_workload_streaming_request()\nstress_workload_streaming_response()\nstress_workload_streaming_bidirectional()\n\nThese run forever, and are useful to help identify any stability issues or resource leaks.","category":"section"},{"location":"#gRPCClient.grpc_init-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_init","text":"grpc_init([grpc_curl::gRPCCURL])\n\nInitializes the gRPCCURL object. This should be called once before making gRPC calls. There is no harm in calling this more than once (ie by different packages/dependencies). Typical usage looks like this:\n\ngrpc_init()\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001)\n\n# Make some gRPC calls \n\n# Shut down the global gRPC handle\ngrpc_shutdown()\n\nUnless specifying a gRPCCURL the global one provided by grpc_global_handle() is used. Each gRPCCURL state has its own connection pool and request semaphore, so sometimes you may want to manage your own like shown below:\n\ngrpc_myapp = gRPCCURL()\ngrpc_init(grpc_myapp)\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001; grpc=grpc_myapp)\n\n# Make some gRPC calls \n\n# Only shuts down your gRPC handle\ngrpc_shutdown(grpc_myapp)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_shutdown-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_shutdown","text":"grpc_shutdown([grpc_curl::gRPCCURL])\n\nShuts down the gRPCCURL. This neatly cleans up all active connections and requests. Useful for calling during development with Revise. Unless specifying the gRPCCURL, the global one provided by grpc_global_handle() is shutdown.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_global_handle-Tuple{}","page":"gRPCClient.jl","title":"gRPCClient.grpc_global_handle","text":"grpc_global_handle()\n\nReturns the global gRPCCURL state which contains a libCURL multi handle. By default all gRPC clients use this multi in order to ensure that HTTP/2 multiplexing happens where possible.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return a gRPCRequest object without waiting for the response. In order to wait on / retrieve the result once its ready, call grpc_async_await. This is ideal when you need to send many requests in parallel and waiting on each response before sending the next request would things down.\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\n# It initializes the underlying libcurl multi handle and other resources.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\n# These bindings define the message types (e.g., TestRequest, TestResponse)\n# and client stubs for your gRPC service. They are generated from .proto files.\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your RPC Method\n# ============================================================================\n# The client is bound to a specific RPC method on your gRPC service.\n# Arguments: hostname, port\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Send Multiple Async Requests\n# ============================================================================\n# Use grpc_async_request when you want to send requests without blocking.\n# This is useful for sending many requests in parallel.\n\n# Send all requests without waiting for responses\nrequests = Vector{gRPCRequest}()\nfor i in 1:10\n    # Each request is sent immediately and returns a gRPCRequest handle\n    push!(\n        requests,\n        grpc_async_request(client, TestRequest(1, zeros(UInt64, 1)))\n    )\nend\n\n# ============================================================================\n# Step 5: Wait for and Process Responses\n# ============================================================================\n# Use grpc_async_await to retrieve the response when you need it.\nfor request in requests\n    # This blocks until the specific request completes\n    response = grpc_async_await(client, request)\n    @info response\nend\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest, Channel{gRPCAsyncChannelResponse{TResponse}}, Int64}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest, channel::Channel{gRPCAsyncChannelResponse{TResponse}}, index::Int64) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return. When the request is complete a background task will put the response in the provided channel. This has the advantage over the request / await patern in that you can handle responses immediately after they are recieved in any order.\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your RPC Method\n# ============================================================================\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Create a Channel to Receive Responses\n# ============================================================================\n# Use the channel-based pattern when you want to process responses as soon\n# as they arrive, regardless of the order they were sent.\nN = 10\nchannel = Channel{gRPCAsyncChannelResponse{TestResponse}}(N)\n\n# ============================================================================\n# Step 5: Send All Requests\n# ============================================================================\n# The index parameter allows you to track which request each response\n# corresponds to, since responses may arrive out of order.\nfor (index, request) in enumerate([TestRequest(i, zeros(UInt64, i)) for i in 1:N])\n    grpc_async_request(client, request, channel, index)\nend\n\n# ============================================================================\n# Step 6: Process Responses as They Arrive\n# ============================================================================\n# Responses are pushed to the channel as they complete. You can process\n# them immediately without waiting for all requests to finish first.\nfor i in 1:N\n    cr = take!(channel)\n\n    # Check if an exception was thrown during the request\n    !isnothing(cr.ex) && throw(cr.ex)\n\n    # Use the index to match responses to requests\n    @assert length(cr.response.data) == cr.index\nend\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_await","text":"grpc_async_await(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nWait for the request to complete and return the response when it is ready. Throws any exceptions that were encountered during handling of the request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_sync_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_sync_request","text":"grpc_sync_request(client::gRPCServiceClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nDo a synchronous gRPC request: send the request and wait for the response before returning it. Under the hood this just calls grpc_async_request and grpc_async_await. Use this when you want the simplest possible interface for a single request.\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your RPC Method\n# ============================================================================\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Make a Synchronous Request\n# ============================================================================\n# This blocks until the response is ready. It's the simplest way to make\n# a single gRPC request when you don't need parallelism.\nresponse = grpc_sync_request(client, TestRequest(1, zeros(UInt64, 1)))\n@info response\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, false}, Channel{TRequest}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,true,TResponse,false}, request::Channel{TRequest}) where {TRequest<:Any,TResponse<:Any}\n\nStart a client streaming gRPC request (multiple requests, single response).\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your Streaming RPC Method\n# ============================================================================\nclient = TestService_TestClientStreamRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Create a Request Channel and Send Requests\n# ============================================================================\n# The channel buffers requests that will be streamed to the server.\n# Buffer size of 16 means up to 16 requests can be queued.\nrequest_c = Channel{TestRequest}(16)\n\n# Send one or more requests through the channel\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\n\n# ============================================================================\n# Step 5: Initiate the Streaming Request\n# ============================================================================\nreq = grpc_async_request(client, request_c)\n\n# ============================================================================\n# Step 6: Close the Request Channel When Done\n# ============================================================================\n# IMPORTANT: You must close the channel to signal that no more requests\n# will be sent. The server won't send the response until the stream ends.\nclose(request_c)\n\n# ============================================================================\n# Step 7: Wait for the Single Response\n# ============================================================================\n# After all requests are sent and processed, the server returns one response.\ntest_response = grpc_async_await(client, req)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, false, TResponse, true}, TRequest, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,false,TResponse,true},request::TRequest,response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a server streaming gRPC request (single request, multiple responses).\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your Streaming RPC Method\n# ============================================================================\nclient = TestService_TestServerStreamRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Create a Response Channel\n# ============================================================================\n# The channel will receive multiple responses from the server.\n# Buffer size of 16 means up to 16 responses can be queued.\nresponse_c = Channel{TestResponse}(16)\n\n# ============================================================================\n# Step 5: Initiate the Streaming Request\n# ============================================================================\n# Send a single request. The server will respond with multiple messages.\nreq = grpc_async_request(\n    client,\n    TestRequest(1, zeros(UInt64, 1)),\n    response_c,\n)\n\n# ============================================================================\n# Step 6: Process Streaming Responses\n# ============================================================================\n# Read responses from the channel as they arrive. The channel will be closed\n# when the server finishes sending all responses.\nfor test_response in response_c\n    @info test_response\nend\n\n# ============================================================================\n# Step 7: Check for Exceptions\n# ============================================================================\n# Call grpc_async_await to raise any exceptions that occurred during the request.\ngrpc_async_await(req)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, true}, Channel{TRequest}, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_request","text":"grpc_async_request(client::gRPCServiceClient{TRequest,true,TResponse,true},request::Channel{TRequest},response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a bidirectional streaming gRPC request (multiple requests, multiple responses).\n\nusing gRPCClient\n\n# ============================================================================\n# Step 1: Initialize gRPC\n# ============================================================================\n# This must be called once before making any gRPC requests.\ngrpc_init()\n\n# ============================================================================\n# Step 2: Include Generated Protocol Buffer Bindings\n# ============================================================================\ninclude(\"test/gen/test/test_pb.jl\")\n\n# ============================================================================\n# Step 3: Create a Client for Your Streaming RPC Method\n# ============================================================================\nclient = TestService_TestBidirectionalStreamRPC_Client(\"localhost\", 8001)\n\n# ============================================================================\n# Step 4: Create Request and Response Channels\n# ============================================================================\n# Both channels allow streaming in both directions simultaneously.\n# Buffer size of 16 means up to 16 messages can be queued in each direction.\nrequest_c = Channel{TestRequest}(16)\nresponse_c = Channel{TestResponse}(16)\n\n# ============================================================================\n# Step 5: Initiate the Bidirectional Streaming Request\n# ============================================================================\nreq = grpc_async_request(client, request_c, response_c)\n\n# ============================================================================\n# Step 6: Send Requests and Receive Responses Concurrently\n# ============================================================================\n# In bidirectional streaming, you can send and receive at the same time.\n# This example shows a simple pattern, but you can use tasks for more\n# complex concurrent communication patterns.\n\n# Send a request\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\n\n# Receive responses as they arrive\nfor test_response in response_c\n    @info test_response\n    # Optionally send more requests based on responses\n    # put!(request_c, ...)\n    break  # Exit after first response for this example\nend\n\n# ============================================================================\n# Step 7: Close the Request Channel When Done\n# ============================================================================\n# IMPORTANT: You must close the request channel to signal that no more\n# requests will be sent.\nclose(request_c)\n\n# ============================================================================\n# Step 8: Check for Exceptions\n# ============================================================================\n# Call grpc_async_await to raise any exceptions that occurred during the request.\ngrpc_async_await(req)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCServiceClient{TRequest, true, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient.jl","title":"gRPCClient.grpc_async_await","text":"grpc_async_await(client::gRPCServiceClient{TRequest,true,TResponse,false},request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nRaise any exceptions encountered during the streaming request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient.gRPCServiceCallException","page":"gRPCClient.jl","title":"gRPCClient.gRPCServiceCallException","text":"Exception type that is thrown when something goes wrong while calling an RPC. This can either be triggered by the servers response code or by the client when something fails.\n\nThis exception type has two fields:\n\ngrpc_status::Int - See here for an indepth explanation of each status.\nmessage::String\n\n\n\n\n\n","category":"type"}]
}
